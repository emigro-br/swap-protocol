// SPDX-License-Identifier: MIT
pragma solidity ^0.8.22;

import "./ISwapAdapter.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

contract EmigroRouter is Initializable, OwnableUpgradeable, ReentrancyGuardUpgradeable {
    using SafeERC20 for IERC20;

    mapping(address => mapping(address => address)) public adapterForPair;
    mapping(bytes32 => address) public adapterForPath;
    mapping(bytes32 => IntentMetadata) public intents;
    mapping(address => bool) public feeExempt;

    struct IntentMetadata {
        address refundTo;
        bool used;
    }

    uint256 public defaultDeadline;
    uint256 public feeBps; // basis points, e.g., 50 = 0.5%
    address public feeReceiver;

    event AdapterSet(address indexed tokenIn, address indexed tokenOut, address indexed adapter);
    event AdapterPathSet(address[] path, address indexed adapter);
    event SwapPerformed(
        address indexed tokenIn,
        address indexed tokenOut,
        uint256 amountIn,
        uint256 amountOut,
        address indexed adapter,
        address recipient
    );
    event RefundIssued(address indexed token, address indexed user, uint256 amount);
    event IntentRegistered(bytes32 indexed intentId, address indexed refundTo);
    event EmergencyWithdrawETH(address indexed to, uint256 amount);
    event EmergencyWithdrawToken(address indexed token, address indexed to, uint256 amount);
    event FeeUpdated(uint256 newFeeBps);
    event FeeReceiverUpdated(address newReceiver);
    event FeeExemptSet(address indexed wallet, bool isExempt);

    // --- Initializer ---

    function initialize() public initializer {
        __Ownable_init(msg.sender);
        __ReentrancyGuard_init();
        defaultDeadline = 300;
        feeBps = 50; // 0.5%
        feeReceiver = 0x3543653A29F9Dc92188c2a68A1e847f8E21f9772;
    }

    // --- Admin ---

    function setAdapterForPair(address tokenIn, address tokenOut, address adapter) external onlyOwner {
        require(adapter != address(0), "Invalid adapter");
        adapterForPair[tokenIn][tokenOut] = adapter;
        emit AdapterSet(tokenIn, tokenOut, adapter);
    }

    function setAdapterForPath(address[] calldata path, address adapter) external onlyOwner {
        require(path.length >= 2, "Invalid path");
        require(adapter != address(0), "Invalid adapter");
        bytes32 pathHash = keccak256(abi.encode(path));
        adapterForPath[pathHash] = adapter;
        emit AdapterPathSet(path, adapter);
    }

    function setDefaultDeadline(uint256 seconds_) external onlyOwner {
        defaultDeadline = seconds_;
    }

    function updateFee(uint256 newFeeBps) external onlyOwner {
        require(newFeeBps <= 1000, "Fee too high");
        feeBps = newFeeBps;
        emit FeeUpdated(newFeeBps);
    }

    function updateFeeReceiver(address newReceiver) external onlyOwner {
        require(newReceiver != address(0), "Zero address");
        feeReceiver = newReceiver;
        emit FeeReceiverUpdated(newReceiver);
    }

    function setFeeExempt(address wallet, bool exempt) external onlyOwner {
        feeExempt[wallet] = exempt;
        emit FeeExemptSet(wallet, exempt);
    }

    // --- Intent Control ---

    function _consumeIntent(bytes32 intentId) internal {
        require(!intents[intentId].used, "Intent already used");
        intents[intentId].used = true;
    }

    function registerIntent(bytes32 intentId, address refundTo) external {
        require(intents[intentId].refundTo == address(0), "Intent already registered");
        intents[intentId] = IntentMetadata({ refundTo: refundTo, used: false });
        emit IntentRegistered(intentId, refundTo);
    }

    // --- Internal Helpers ---

    function _chargeFee(address token, address from, uint256 amount) internal returns (uint256 netAmount) {
        if (feeBps == 0 || feeExempt[from]) {
            return amount;
        }

        uint256 fee = (amount * feeBps) / 10000;
        netAmount = amount - fee;

        if (fee > 0) {
            IERC20(token).safeTransferFrom(from, feeReceiver, fee);
        }
    }

    // --- Pair-Based Swaps ---

    function swapExactInput(
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 minAmountOut,
        address recipient,
        bytes32 intentId,
        bytes calldata data
    ) external payable nonReentrant returns (uint256 amountOut) {
        _consumeIntent(intentId);
        address adapter = adapterForPair[tokenIn][tokenOut];
        require(adapter != address(0), "No adapter set for pair");

        uint256 netAmount = _chargeFee(tokenIn, msg.sender, amountIn);
        _handleTransfer(tokenIn, adapter, netAmount);

        try ISwapAdapter(adapter).swapExactInput(tokenIn, tokenOut, netAmount, minAmountOut, recipient, data) returns (uint256 result) {
            amountOut = result;
            emit SwapPerformed(tokenIn, tokenOut, netAmount, amountOut, adapter, recipient);
        } catch {
            _attemptRefund(tokenIn, intents[intentId].refundTo, netAmount);
            revert("Swap failed and refunded");
        }
    }

    function swapExactOutput(
        address tokenIn,
        address tokenOut,
        uint256 maxAmountIn,
        uint256 amountOut,
        address recipient,
        bytes32 intentId,
        bytes calldata data
    ) external payable nonReentrant returns (uint256 amountInUsed) {
        _consumeIntent(intentId);
        address adapter = adapterForPair[tokenIn][tokenOut];
        require(adapter != address(0), "No adapter set for pair");

        uint256 netAmount = _chargeFee(tokenIn, msg.sender, maxAmountIn);
        _handleTransfer(tokenIn, adapter, netAmount);

        try ISwapAdapter(adapter).swapExactOutput(tokenIn, tokenOut, netAmount, amountOut, recipient, data) returns (uint256 result) {
            amountInUsed = result;
            emit SwapPerformed(tokenIn, tokenOut, amountInUsed, amountOut, adapter, recipient);
        } catch {
            _attemptRefund(tokenIn, intents[intentId].refundTo, netAmount);
            revert("Swap failed and refunded");
        }
    }

    // --- Path-Based Swaps ---

    function swapExactInputPath(
        address[] calldata path,
        uint256 amountIn,
        uint256 minAmountOut,
        address recipient,
        bytes32 intentId,
        bytes calldata data
    ) external payable nonReentrant returns (uint256 amountOut) {
        _consumeIntent(intentId);
        require(path.length >= 2, "Invalid path");
        address adapter = adapterForPath[keccak256(abi.encode(path))];
        require(adapter != address(0), "No adapter set for path");

        uint256 netAmount = _chargeFee(path[0], msg.sender, amountIn);
        _handleTransfer(path[0], adapter, netAmount);

        try ISwapAdapter(adapter).swapExactInputPath(path, netAmount, minAmountOut, recipient, data) returns (uint256 result) {
            amountOut = result;
            emit SwapPerformed(path[0], path[path.length - 1], netAmount, amountOut, adapter, recipient);
        } catch {
            _attemptRefund(path[0], intents[intentId].refundTo, netAmount);
            revert("Swap path failed and refunded");
        }
    }

    function swapExactOutputPath(
        address[] calldata path,
        uint256 maxAmountIn,
        uint256 amountOut,
        address recipient,
        bytes32 intentId,
        bytes calldata data
    ) external payable nonReentrant returns (uint256 amountInUsed) {
        _consumeIntent(intentId);
        require(path.length >= 2, "Invalid path");
        address adapter = adapterForPath[keccak256(abi.encode(path))];
        require(adapter != address(0), "No adapter set for path");

        uint256 netAmount = _chargeFee(path[0], msg.sender, maxAmountIn);
        _handleTransfer(path[0], adapter, netAmount);

        try ISwapAdapter(adapter).swapExactOutputPath(path, netAmount, amountOut, recipient, data) returns (uint256 result) {
            amountInUsed = result;
            emit SwapPerformed(path[0], path[path.length - 1], amountInUsed, amountOut, adapter, recipient);
        } catch {
            _attemptRefund(path[0], intents[intentId].refundTo, netAmount);
            revert("Swap path failed and refunded");
        }
    }

    // --- Token Transfer Logic ---

    function _handleTransfer(address token, address to, uint256 amount) internal {
        if (token == address(0)) {
            require(msg.value == amount, "Incorrect ETH sent");
            (bool success, ) = to.call{value: amount}("");
            require(success, "ETH transfer failed");
        } else if (!_isSmartContract(msg.sender)) {
            IERC20(token).safeTransferFrom(msg.sender, to, amount);
        } else {
            require(IERC20(token).balanceOf(to) >= amount, "Tokens not sent to adapter");
        }
    }

    function _attemptRefund(address token, address to, uint256 amount) internal {
        if (token != address(0)) {
            try IERC20(token).transfer(to, amount) {
                emit RefundIssued(token, to, amount);
            } catch {
                // Silent fail
            }
        } else {
            (bool success, ) = to.call{value: amount}("");
            if (success) emit RefundIssued(address(0), to, amount);
        }
    }

    function _isSmartContract(address account) internal view returns (bool) {
        return account.code.length > 0;
    }

    // --- Emergency Recovery ---

    function emergencyWithdrawETH(address to) external onlyOwner {
        uint256 balance = address(this).balance;
        require(balance > 0, "No ETH to withdraw");
        (bool success, ) = to.call{value: balance}("");
        require(success, "ETH transfer failed");
        emit EmergencyWithdrawETH(to, balance);
    }

    function emergencyWithdrawToken(address token, address to) external onlyOwner {
        uint256 balance = IERC20(token).balanceOf(address(this));
        require(balance > 0, "No token balance");
        IERC20(token).safeTransfer(to, balance);
        emit EmergencyWithdrawToken(token, to, balance);
    }

    receive() external payable {}
}
